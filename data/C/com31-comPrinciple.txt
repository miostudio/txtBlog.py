计算机底层原理、计算机网络、操作系统





========================================
1. 计算机组成
----------------------------------------
1.
paska，莱布尼茨 发明计算器。
西班牙 二进制。

图灵机: 占地一个别墅。
二极管，晶体管，集成电路/芯片。




2. 计算机重要的是 CPU 和 内存。

CPU 很快，而内存很慢。

CPU访问寄存器 1ns，访问内存需要100ns。
在内存中加缓存，稍微快点。
缓存越多，更新时需要更新的越多。
越少，则访问越慢。

实际使用的是3级缓存。





3. 三级缓存

(1) 比如一个CPU有2个核，
每个核分别有一个L1，L2 缓存，
两个核共用一个L3缓存，通过L3缓存和内存直接相连。

一个核在同一个时间只能执行一个线程。

(2) 查找的过程
如果一个线程需要数据x，在L1缓存查找，
如果没找到，则到L2缓存找，
如果没找到，则到L3缓存找，
如果没找到，则到内存找，
找到了，则依次在公用的 L3 留一个备份，
在自己核的L2留一个备份，
在自己核的L1留一个备份，
返回给CPU 计算单元。


(3) 进一步优化
一次访问多取数据，把空间相邻的元素都取出来，放到缓存中。
比如，访问数组第一个元素，就把数组整体都取出来，并放到缓存中。



(4) 一次取多少合适？
大有大的便捷，
小有小的优势。

现在主流是 64个字节 bytes (== 8位)。
我用一个数据的时候，把这一行都取出来了。
CPU取数据的基本单位是 缓存行 cache line.


(5) 缓存的一致性协议
MESI 是一种协议。不同硬件不同的协议。

缓存的一致性协议是硬件层面的，软件上不能控制。

怎么能看到这一点呢？
启动2个线程，分别改写一个整数变量，改写1e8次，看执行多久。
然后在变量前后放7个整数，保证他们不位于相同的 缓存行，看这姓多久。
前者时间明显更长。原因就是因为两个数太近了会不同的触发缓存同步，浪费了很多时间。
例子: https://www.bilibili.com/video/BV1hZ4y1i724?p=4  7'


有一个著名的 消息中间件 Disruptor，号称最快的消息队列，用了这种写法。
	https://blog.csdn.net/weixin_48052161/article/details/120591943
	使用了环形缓冲区 (ring buffer)，只需要一个指针，这个指针的前后各放了7个 long p1-p7，后面再也没用过了。
	第一次提出 cas 概念。



(6) 多线程编程的3个要点：可见性、有序性、原子性


(7) 指令重排:
	两行语句，分别在2个线程执行，则它们的顺序可能是乱的。
	
	a=0, b=0, x=0,y=0;
	
	{ a=1; x=b; }
	{ b=1; y=a; }
	监控 x+y==0 的出现情况:
	在个线程中的2句话可能同时翻转了执行顺序，也就是
	只有 x=b; y=a; a=1;b=1; 时出现 x+y==0


(8) 新建对象的时候发生了什么？
Object t1=new Object();
T t1=new T();

第一步 new 申请空间，大小和T类型的大小。
第二步 执行T类的构造方法，赋初始值。
第三步 把初始化后的对象和变量链接。

不要在java的构造方法中启用任何线程！
	因为没有完成初始化，可能读到变量的原始值。


(9) 单例模式(懒汉模式)遇到多线程，不能保证单例，怎么办？
1)加锁: synchronized()
	保证原子性：不能被打断；
	保证可见性，
	但是不保证有序性

2)但是加锁后可能还是不能保证单例，需要在锁内再次判断是否单例。

class Mgr06{
	private static Mgr06 INSTANCE=null;
	private mGR06(){} //私有的构造方法

	public static Mgr06 getInstance(){
		//业务逻辑代码略
		if(INSTANCE ==null){ //检查
			//双重检查
			synchronized(Mgr06.class){ //中间一把锁
				if(instance == null){ //检查 again
					INSTANCE = new Mgr06();
				}
			}
		}
		return INSTANCE;
	}
}
考虑到多进程每个进程的cpu时间是不确定的，谁能执行到哪不好预测:
第一个进程过来，上锁；
第二个进程进来，上锁，new 对象，返回，解锁。
	第一个进程继续，发现有对象了，直接返回。


3) 以上还是有问题的：指令重排怎么办？

DCL单例(Double check Lock)到底需不需要 volatile?

正常:
	1 new 空间
	2 初始化变量
	3 建立对象和变量名的关联

指令重排后:
	1 new 空间
	3 建立对象和变量名的关联
	2 初始化变量

第一个进程进来，上锁，开始new 对象，发生指令重派了，也就是先建立了变量和对象空间的联系，还没有完成初始化；
第二个进程进来，发现对象已经存在，直接返回该没有初始化的对象。


乱序执行，在单线程能提高效率，但是多线程，有可能出现意外的bug。

volatile: 防止乱序

private static volatile Mgr06 INSTANCE=null; //神奇的修饰符

JVM 对 volatile 修饰的变量，都有一些特定的操作:
	操作系统层面：内存屏障，主要是CPU指令，lfence,mfence,...
	JVM层面：java的内存屏障，主要有4种。
	


如果一个问题很复杂，就分层出来，一层不行多分几层。
	

感觉这个视频不对劲：不继续看了。除了第一节，不像是计算机组成原理。
https://www.bilibili.com/video/BV1hZ4y1i724?p=10
每个视频都是讲个开头，虎头蛇尾。可能是卖课程的。







========================================
** 计算机组成原理（哈工大刘宏伟）135讲（全）高清 **
----------------------------------------
1.核心词汇:

计算机 computor
组成 organization 
原理 principle

课程不以具体机型为主导。
自顶向下的设计方法。


课本：唐硕飞
参考教材: 
David A.Patterson, John L.Hennessy:
	Computer Organization & Design: A Hardware/Software Interface

David Hrris:


2. 计算机 
(1) 
存储器
IO
系统总线
CPU 

(2) CPU 中央处理器
ALU
CU
CPU 内部互联
寄存器

(3) CU 控制单元
排队逻辑
寄存器和解码器
控制存储器



3. 本课程分隔
机器
	基本概念
	总线
	存储器
	IO
数字
	数的表示
	运算方法和运算器
CPU 
	指令系统
	CPU的结构和功能
	控制单元 
	控制单元的设计



========================================
1.硬件
----------------------------------------
1. 计算机系统
传感器
手机
笔记本
PC
server
mainframe
HPC
物联网


(2) HPC
天河2有 312万个核。




2. 计算机的组成
主要是2块: 硬件、软件。

软件：
	系统软件：用来管理整个计算机系统
		语言处理程序
		操作系统
		服务性程序
		数据库管理系统
		网络软件
	
	应用软件：按任务需要编制的各种程序
		游戏
		word

硬件提供指令集，可以被软件调用。


3. 计算机系统的层次结构
(1) 系统复杂性的管理方法：抽象
抽象：隐藏系统中不重要的细节。

(2)从物理角度，计算机可以抽象为9层。
	电子-逻辑-...

(3)从程序员角度，计算机可以抽象为5层。
	微指令系统
	机器语言
	汇编语言
	操作系统(中介)
	高级语言



4. 计算机体系结构和计算机组成


应对复杂性的方法：抽象。
	如果太复杂，再多几层抽象。




5. 冯诺依曼计算机的特点

(1)由5个结构：输入设备、输出设备、运算器、控制器、存储器。
(2) 指令和数据同等地位保存在存储器中，可以按地址寻访。
(3) 指令和数据用二进制表示
(4) 指令由操作码和地址码组成
(5) 存储程序
(6) 以运算器为中心

问题：
运算器为中心，==> 改为存储器为中心。
流程太乱。

硬件：
	主机
		CPU: ALU + CU 
		主存
	IO设备
		输入设备 
		输出设备 
		辅存


6. 系统复杂性管理的方法2: 3Y
(1) 层次化 Hierachy: 将被设计的系统划分为多个模块和子模块。
(2) 模块化 Modularity: 有明确定义的功能和接口
(3) 规则化 regularity: 模块更容易被重用



7. 计算机的工作步骤

(1)一个问题，能否用计算机解决？
是不是所有的问题都可以用计算的方法来解决。

假设我们遇到的问题可以用计算机解决，
然后怎么解决呢？

(2) 上机前的准备
建立数学模型
确定计算方法
编程序

指令格式： 操作码 地址码




8. 计算机的解题过程
(1) 存储器的基本组成
存储体: MAR MDR
	MAR:memory address register 存储器地址寄存器，反映存储单元的个数。
	MDR: memory data register 存储器数据寄存器，反映存储字长

设 MAR=4, MDR=8,存储单元个数是:


(2) 运算器的基本组成及操作过程
加减乘除的实现方法: 
	乘法分高低位
	MQ: 乘商寄存器
	ACC:
P8 //不是太懂 https://www.bilibili.com/video/BV1t4411e7LH?p=8


(3) 控制器的基本结构
功能：
	解释指令
	保证指令的按序执行

完成一条指令：
	取指令: PC 程序寄存器，存放当前要执行指令的地址，具有计数功能 PC+1->PC
	分析指令: IR 存放当前要执行的执行
	执行指令: CU 完成。


执行过程：以取指令为例
	控制器的 PC 指向 住存储器的 MAR，
	根据地址找到存储体中的指令，
	找到后返回给 MDR，
	然后送给控制器的IR。




9.打算买一台机器，怎么选合适？

(1) 买这台机器做什么？
(2) 你有多少钱
(3) 机器的性能能否满足你的要求？
	如何评价性能？
		* 处理速度快、价格便宜

(4) 计算机硬件的主要技术指标
机器字长：CPU中寄存器的位数有关，一般是 8 位。
	越长越好。

(5) 运算速度
从指令执行的角度衡量。

主频
核数，每个核支持的线程数
吉普森法 Tm=累加(i=1, n, fi*ti)
	频率*时间
CPI: 执行一条指令所需要的时钟周期数
	越少越好，
	IPC: 一个时钟周期执行指令数
MIPS: 每秒执行指令数

FLOPS: 每秒浮点运算次数。更科学。


(6) 存储容量
存放二进制信息的总位数。

主存容量
	存储单元个数 * 存储字长
		如 MAR MDR 容量
		    10  8   1k*8位
			16  32  64*32位
	字节数  2%13b=1kB
辅存容量 字节数 80Gb





========================================
2. 计算机的发展及应用
----------------------------------------

1. 计算机的发展史
1946年 美国 ENIAC.
1955年 退役。

没有存储器。

技术发展的驱动力
	电子 
	体系

计算机的更新换代，主要是硬件的进步:
	电子管-晶体管-集成电路


(2) ISA
冯诺依曼结构。

(3) IBM System /360
里程碑式的，是一个系列产品。
先订立软硬件交界面，然后软件和硬件可以同时构建。
相同的软件，在同一个系列机器上可以兼容。



2. 微型计算机的出现和发展
(1) 1971年 4 位 微处理器芯片

(2) intel 公司的典型处理器产品




3. 软件技术的兴起和发展
(1)编程语言

(2)系统软件
操作系统
服务性程序
数据库管理软件

(3) 软件发展的特点
开发周期长
制作成本昂贵
检测软件产品质量的特殊性
	按行覆盖
	分支覆盖

需求分析和测试占了一半的成本。

软件是程序以及开发、使用和维护程序所需要的所有文档。



4. 计算机的应用
(1) 科学计算和数据处理
大气建模
银行数据处理

(2)工业控制和实时控制

(3)网络技术
	电子商务
	网络教育
	敏捷制造: 

(4)虚拟现实 VR
飞行训练系统。

(5) 办公自动化和管理信息系统
(6) CAD/CAM/CIMS
计算机辅助设计-制造

(7)多媒体技术
(8)人工智能


5. 计算机的展望
(1)类人脑超级智能
计算机要足够快

(2)芯片集成度的提高受到三个限制
物理极限的制约
成本是几何级数递增
功耗、散热等

(3)替代硅芯片的方案？
光计算机
DNA
量子





========================================
3. 总线(bus)的基本概念
----------------------------------------
1. 为什么要用总线?
通信太多
为了方便升级

2.什么是总线
连接各个部件的信息传输线
是各个部件共享的传输介质。

3. 总线上信息的传送
串行
并行

4.总线结构的计算机举例
(1) 单总线结构框架图
(2) 面向CPU的双总线
IO总线: 其他设备。
M总线: CPU和主存之间通信。

(3) 以存储器为中心的双总线结构框图
系统总线 
存储总线



5. 总线的分类
(1) 片内总线
芯片内部的总线。

(2) 系统总线 计算机各个部件之间的信息传输线。
数据总线 双向
地址总线 单向
控制总线 有出 有入

(3) 通信总线
计算机与其他计算机或其他硬件的通信。

串行、并行。





6. 总线特性和性能指标
总线是印刷到板子上的，叫主板

(1) 总线特性 
机械特性
电气
功能
时间 

(2) 性能指标 
总线宽度: 根数，越多越好。
标准传输率: 每秒传输的最大字节数(MBps)
时钟同步/异步
总线复用: 地址线、数据线 复用
信号线数
总线控制方式
其他指标

(3) 总线标准
ISA   16MBps 带宽
EISA
PCI  132 - 528 MBps 
AGP  266 - 533 MBps;
...
USB




7. 总线结构
(1) 双总线结构
主存总线
I/O总线

(2) 三总线结构
增加 DMA 总线

(3) 三总线结构的又一形式
扩展总线

(4) 四总线结构
系统总线、局部总线
高速总线、扩展总线


8. 总线结构举例
(1) 
(2)
(3) PCI 总线结构 
(4) 多层 PCI 总线结构



9. 总线控制
(1) 总线判优控制
主设备(模块): 对总线有控制权
从设备(模块): 响应 从主设备发来的总线命令

集中式
	* 链式查询：优先权依赖，电路故障则无法下发；结构简单。
	* 计数器定时查询方式: 增加设备地址线，内部计数器
	* 独立请求方式: 内部排队器

分布式

(2) 总线通信控制
目的：解决通信双方 协调配合 的问题。
总线传输周期:
	* 申请分配阶段：主模块申请，总线仲裁决定
	* 寻址阶段：主模块向从模块 给出地址 和 命令
	* 传输阶段：主模块和从模块 交换数据
	* 结束阶段：主模块 撤销有关消息

(3) 总线通信的四种方式
* 同步通信: 统一时标（定宽定距的时钟）
	在给定的时间，进行规定的操作。
* 异步通信 应答方式
	增加两条线
	不互锁: 主设备发出信号，从设备接收信号，发出应答，不可靠。
	半互锁: 可能主设备收不到一直发请求
	全互锁: 比较可靠
* 半同步..: 同步、异步结合
* 分离式..: 充分挖掘系统总线的潜力


总线传输周期，前三种方式，一共三个步骤:
主模块发送地址、命令
从模块准备 发送/接收 数据: 不需要占用总线。
从设备 发送/接收 数据


而分离式，一个总线传输周期分为2个阶段：
子周期1: 主模块 申请 占用总线，使用完后放弃总线的使用权。
子周期2: 从模块申请 占用总线，将各种信息发送至总线上。
	子周期2相当于从模块变成主模块。







========================================
第4章 存储器
----------------------------------------

1. 存储器分类
(1) 按存储介质
* 半导体存储器: TTL, MOS
* 磁表面存储器: 磁头、磁载体
* 磁芯存储器: 王安发明的
* 光盘存储器

半导体没电信息易失。

(2) 按照存取时间
* 随机访问：随机存储器 / 只读存储器
* 存取时间与物理地址有关(串行访问)
	顺序存取存储器：磁带
	直接存取存储器：磁盘

(3) 计算机中的作用
主存储器
	RAM: 静态/动态
	ROM: MROM / P- / EP- / EEP-
flash memory: U 盘
	SSD
高度缓冲存储器: Cache
辅助存储器: 硬盘、光盘、磁带



2. 存储器的层次结构
(1) 存储器三个主要特征的关系
速度 寄存器>缓存>主存>磁盘>光盘>磁带
容量  <
价格/位  >

(2) 高速、大容、低价格
只能用存储系统来达到这几个要求。


(3) 缓存 - 主存层次 和 主存-辅存层次
CPU 10ns
缓存 20ns
主存 200ns
辅存 ms

虚拟存储器: 
	虚地址
	逻辑地址



3. 主存储器
(1) 主存的基本组成
其实很复杂。

(2) 主存和CPU的连接
双向的
三种信号

(3) 主存中存储单元地址的分配
一个存储单元是8位地址。
比如 12345678H 这个数据如何在主存储器中进行存储？

1)高位字节 地址为字地址
字地址  字节地址
     0  12  34  56 78
     4
     8
大端、大尾方式: 就是尾巴位置较高位。


2) 低位字节 地址为字地址
字地址  字节地址
     0  78  56  34  12
     4
     8
小端、小尾方式: 就是尾巴位置是低位。

两种方式没有区别。

设地址线 24 根，按 字节 寻址 2^24=16MB
若字长为 16 位，按 字 寻址 8MW
若字长为 32 位，按 字 寻址 4MW




4. 主存的技术指标
(1) 存储容量 
(2) 存储速度
存取时间: 
存取周期:

(3) 存储器的宽带 位/秒









5. 半导体存储芯片简介
(1) 基本结构
地址线
片选线: CS / CE 数据到底在内存条的那一块中？
译码驱动
存储矩阵
读写电路
数据线 
读/写控制线：WE / OE

16k x 1位 存储器芯片组成 64K x 8位的存储器。
8片 16K*1为 一列， *4列


(2) 译码驱动 方式
* 线选法:
	地址译码器: 需要数字电路前置知识
	
* 重合法:
	X 地址译码器
	Y 地址译码器







6. 随机存取存储器 - 现在用的内存条

(1) 静态 RAM(SRAM)
保存0和1的原理是什么？ 
	触发器。 -- 需要数字电路前置知识

基本单元电路的构成是什么?
对单元电路如何读出和写入？

典型芯片的结构式什么样子的？


静态RAM芯片是如何进行读出和写入操作？


// todo 看不懂， Intel 2114 RAM 矩阵读写细节。















========================================
cur: 28/135
----------------------------------------
https://www.bilibili.com/video/BV1t4411e7LH?spm_id_from=333.337.search-card.all.click&vd_source=826befc4ac0d0fa3b98deaa3efc7f800

https://www.bilibili.com/video/BV1t4411e7LH?p=9

历史记录:
2022.7.6 10
2022.7.7 11,12,13,14,15,16,
2022.7.12 16,17,18,19,
2022.7.17 20,21,22,
2022.7.19 22,23,24
2022.7.21 24,25,26,27,
2022.7.26 27,28,















========================================
【麻省理工学院-中文字幕版】计算机组成原理（完整版）讲明白了
----------------------------------------
每天听一段，至少 5 min;
2022.7.12 =>02
2022.7.17 03,4,5,
2022.7.22 5,
https://www.bilibili.com/video/BV1kU4y177x9?p=2&spm_id_from=pageDriver&vd_source=826befc4ac0d0fa3b98deaa3efc7f800


1. information content

information content = log2(1/P)，P是事件的概率。
比如一个游戏: 
猜测玩家手里的扑克牌是哪一张，你将获取一条信息，你判断该信息是否有用时，就可以用 信息含量 来量化。

问题  /概率  /信息含量
不是方块A的概率 P=51/52,  log2(1/P)=0.028 bits
一个红桃的概率是 P=12/52, log2(1/P)=2 bits
a face card(J,Q,K) P=12/52,  log2(1/P)=2.115 bits


小结:
information content 越高，信息含量越高，我们能推断出是哪张牌的可能性越大。





2. 熵 Entropy H(X)
对于数据中每个X值包含的信息的平均值。
H(X)=E( I(X) )=求和(i=1, N,  pi*log2(1/pi) )


X={A,B,C,D}
choice,  Pi,  log2(1/p)
A       1/3   1.58 bits
B       1/2   1 bits
C       1/12  3.58 bits
D       1/12  3.58 bits

比如:
H(X)=1/3*1.58 + 1/2*1+ 2/12*3.58=1.626 bits





3. Encoding 
如果有N个字符需要编码，则需要的信息量是
求和(i=1, N, 1/N*log2(1/(1/N) ))=log2(N)
正好是二进制需要的位数。
比如 ascii码 94个可打印字符，需要 log2(94)=6.555













========================================
----------------------------------------






========================================
----------------------------------------


========================================
----------------------------------------






========================================
----------------------------------------


========================================
----------------------------------------






========================================
----------------------------------------


========================================
----------------------------------------






========================================
----------------------------------------


========================================
----------------------------------------






========================================
----------------------------------------


========================================
----------------------------------------



