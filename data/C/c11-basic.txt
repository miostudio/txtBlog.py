c11-basic



========================================
Why and how to learn C语言
----------------------------------------
1. why?
学计算机基础。
某些R和py包太慢时考虑使用C语言实现关键步骤。


(1) 丰富的数据类型 
C具有整型、浮点型、字符型、数组类型、指针类型、结构体类型、共用体类型等多种数据类型。特别是C的指针类型，功能强大、灵活方便。
(2) 结构化的控制语句 
C语言的控制结构语句符合结构化程序设计要求如if...else语句、whi1e语句、do…whi1e语句、for语句，并且用函数作为程序模块，使得程序结构清晰、可读性好、易于调试。
(3) 高效率的目标代码 
能进行位（ｂｉｔ）操作，能实现汇编语言的大部分功能，可以直接对硬件进行操作，因此Ｃ既具有高级语言的功能，又具有低级语言的许多功能，可用来写系统软件。Ｃ语言的这种双重性，使它既是成功的系统描述语言，又是通用的程序设计语言。有人把Ｃ称为“高级语言中的低级语言”，也有人称它为“中级语言”意为兼有高级和低级语言的特点。
(4) 用Ｃ语言写的程序可移植性好（与汇编语言比） 






2. How?

(1) 跟着书学习，先学习大概，然后再学习细节。
有大概后再看怎么深入，走一步看三步，少做无用功。

github: miostudio/learn_C
local: G:\learn_C




(2) 经典书推荐：中文版
C语言程序设计第三版(谭浩强).pdf 没找到排版好的版本。
标准C语言基础教程第四版.pdf
中兴C语言教材.doc  180页


(3) 经典书推荐: 英文版
一本全面的C语言入门教程(第三版).pdf






========================================
基础版本
----------------------------------------
#include<stdio.h>
int main(){
	printf("Hello world, c");
	return 0;
}

1. 每行结尾必须是分号;
2. 第一行是预处理头
3. 接着是一个 int main()函数，返回值是int
4. 函数体内打印出字符

5. 变量必须指定类型，先定义，再使用。





========================================
结构化程序设计方法
----------------------------------------
- 自顶向下；
- 逐步细化；
- 模块化设计；
- 结构化编码。




========================================
day01: 数据类型、运算符与表达式
----------------------------------------
1. 在Ｃ语言中，数据类型可分为：
- 基本数据类型，
	整型 int 
	字符型 char （注：C中没有字符串类型）
	实型(浮点型)
		单精度型 float
		双精度型 double
- 构造数据类型，
	数组类型 
	结构体类型 
	共用体(联合)类型
- 指针类型，
- 空类型四大类。




2.
Long	长型
short	短型

signed	有符号型
unsigned	无符号型

short型和long型用于整型和字符型，
	其中long型还可以用于双精度型。
	short型不常用，对于不同机型取值范围不同，这里不再介绍。

有符号型signed和无符号型unsigned适用于char型、int型和long型三种类型，
	区别在于它们的最高位是否作为符号位。


char 0-127, 





3. 表达式中数据类型转换
(1) 自动类型转换
C语言规定，不同类型的数据在参加运算前会自动转换成相同类型，再进行运算。转换的规则如图所示

float -> double 

char,short --> int -> unsigned -> long -> double

一个int型与一个Long型数据运算，先将int型转换成1ong型



(2) 强制类型转换




4.算术运算符和算术表达式

(1). 算术运算符     (见2．8．2节)
C语言规定负值运算符优先级高于乘、除、模运算符，乘、除、模运算符优先级高于加、减运算符，当表达式中优先级相同时，按照运算符的结合性。如果需要先计算优先级低的可以使用小括号“（）”，小括号的优先级最高。

(2). 关系运算符     (>  <  ==  >= <=  !=)
(3). 逻辑运算符     (！ ＆＆ ||)
(4). 位运算符       (<<  >>  ~  |  ^  &)
(5). 赋值运算符     (= 及其扩展赋值运算符)
(6). 条件运算符     (?:)
条件运算符是C语言的唯一的三目运算符，即它需要3个数据或表达式构成条件表达式。
它的一般形式为：表达式1？表达式2：表达式3

(7). 逗号运算符     (,)
整个逗号表达式的值是最后一个表达式的值。
逗号表达式的结合性从左往右，它的优先级是最低的。

(8). 指针运算符     (* 和 &)
(9). 求字节数运算符 (sizeof)
(10)．强制类型转换运算符  （类型）
(11)．分量运算符          （． →）
(12)．下标运算符          （[ ]）
(13)．其它                （如函数调用运算符() ）













========================================
day02: 控制结构
----------------------------------------
1. 选择结构： if()...else{}，switch(){ case }

(1)如何获取键盘输入的整数？
	int n;
	printf("input a score bewtween [0, 100]: ");
	//n=getchar();
	scanf("%d", &n);
	printf("Your input is %d\n", n);


(2) switch 结构 

switch(表达式){  
        case 常量表达式1:  语句1;  
        case 常量表达式2:  语句2;  
        …  
        case 常量表达式n:  语句n;  
        default        :  语句n+1;


其语义是：计算表达式的值。 并逐个与其后的常量表达式值相比较，当表达式的值与某个常量表达式的值相等时， 即执行其后的语句，然后不再进行判断，继续执行后面所有case后的语句。 如表达式的值与所有case后的常量表达式均不相同时，则执行default后的语句。
直到遇见break才跳出switch语句。缺省default，当没有与表达式值相等的数值时，直接跳出switch语句。

- 在case后的各常量表达式的值不能相同，否则会出现错误。
- 在case后，允许有多个语句，可以不用{}括起来。
- 各case和default子句的先后顺序可以变动，而不会影响程序执行结果。
- default子句可以省略不用。 






2. 循环结构
for语句、while语句和do-while语句

理解break、continue语句的使用特性以及应用范畴
了解goto语句的使用方法

(1)
do-while语句的表达式后面则必须加分号。do-while和while语句相互替换时，要注意修改循环控制条件。


(2)
for语句是Ｃ语言所提供的功能更强，使用更广泛的一种循环语句。其一般形式为：    
for(表达式1；表达式2；表达3)  
在整个for循环过程中，表达式1只计算一次，表达式2和表达式3则可能计算多次。循环体可能多次执行，也可能一次都不执行。










========================================
day03: 函数
----------------------------------------
Ｃ语言中的函数相当于其它高级语言的子程序。

1. 定义形式

类型标识符 函数名(形参类型说明表列) 
{ 
 函数体
}



2. 函数的返回值
return (表达式)；
作用：返回一个值给调用他的变量，并立即退出当前函数。


3. 嵌套调用

C语言中函数不能嵌套定义，但是可以嵌套调用，即在调用一个函数的过程中可以又调用另一个函数。


4. 递归

在编写递归算法的时要特别注意：递归调用必须可以满足一定条件时结束递归调用，否则无限地递归调用将导致程序无法结束。


5. 可见性

C中所有函数的作用域都处于同一嵌套程度, 即不能在一个函数内再说明或定义另一个函数。

C中一个函数对其它子函数的调用是全程的, 即使函数在不同的文件中, 也不必附加任何说明语句而被另一函数调用, 也就是说一个函数对于整个程序都是可见的。 



6. 调用另一个文件的函数
//定义函数的源文件
$ cat 02_fn.c
int add(int x, int y){
	return x+y;
}


#include<stdio.h>
# include "02_fn.c" //引用函数源文件
int main(){
	printf("add(1,2)=%d\n", add(1,2));
}








========================================
day04: 数组
----------------------------------------
一维数组、二维数组。
函数参数时的传参方式：数组名作参数


1. 一维数组 

int num[5];

方括号中常量表达式表示数组元素的个数，如a[5]表示数组a有5个元素。但是其下标从0开始计算。因此5个元素分别为a[0],a[1],a[2],a[3],a[4]。

不能在方括号中用变量来表示元素的个数， 但是可以是符号常数或常量表达式。


2. 二维数组的定义形式为

类型标识符 数组名[元素个数1][元素个数2]； 

int a[3][4]; 
按行顺次存放，先存放a[0]行，再存放a[1]行，最后存放a[2]行。
每行中有四个元素也是依次存放。



(2) 赋值 
按行分段赋值可写为
int a[5][3]={ {80,75,92},{61,65,71},{59,63,70},{85,87,90},{76,77,85} };    

按行连续赋值可写为
int a[5][3]={ 80,75,92,61,65,71,59,63,70,85,87,90,76,77,85 };    

这两种赋初值的结果是完全相同的。






========================================
day05/ 字符与字符串
----------------------------------------
1. getchar()函数 和 scanf()函数

int  getchar(void )；

getchar()函数同带格式符%c的scanf()函数都可以接收一个字符，并且可以将得到的字符赋给一个字符型变量或者整型变量。 
但是不是所有场合二者都可以互相替换。下面我们列出了它们的不同之处： 
1） getchar()一次只能接收一个字符。
2） getchar()可以接收回车字符。而scanf()将回车作为数据的间隔符或结束符。
3） getchar()接收的字符可以不赋给任何变量。





2. 字符输出函数putchar()

putchar()函数作用是将一个字符输出到输出设备（如显示器）。它的一般形式为
       int putchar(int c)；  
函数putchar()的可以输出字符型变量、整型变量、字符型常量以及控制字符和转义字符。

有上述例子可以看出putchar（）函数只能输出一个字符，而printf()函数可以同时输出多个字符。




3.输出字符串时

printf函数中，使用的格式字符串为“%s”， 表示输出的是一个字符串。
而在输出表列中给出数组名则可。




4. scanf函数

当用scanf函数输入字符串时，字符串中不能含有空格，否则将以空格作为串的结束符。




5.字符串的输入和输出函数

在C语言提供了字符串的输入输出函数gets()和puts()，它们在头文件“stdio.h”中定义的，用于整串字符串的输入输出。


(1) 字符串输出函数puts()
puts()函数作用是将一个字符串（以'\0'结束的字符序列）输出，其一般形式为 puts(字符数组名)； 或 puts(字符串)；

- 函数puts()一次只能输出一个字符串。
- 函数puts()可以输出转义字符。
- 函数puts()输出字符串后自动换行。

printf()函数可以同时输出多个字符串，并且能灵活控制是否换行。所以printf()函数比puts()函数更为常用。


(2) 字符串输入函数gets()
gets()函数作用是将一个字符串输入到字符数组中，其一般形式为 gets(字符数组名)；
gets()函数同scanf()函数一样，在读入一个字符串后，系统自动在字符串后加上一个字符串结束标志'\0'。


函数gets()的使用时要注意以下几个问题：
- 函数gets()只能一次输入一个字符串。
- 函数gets()可以读入包含空格和TAB的全部字符，直到遇到回车为止。

使用格式符“%s”的函数scanf()，以空格、TAB或回车作为一段字符串的间隔符或结束符，所以含有空格或TAB的字符串要用gets()函数输入。





6. 字符串操作函数

C语言提供了很多字符串操作函数，其对应的头文件为string.h。

(1) 字符串拷贝函数 strcpy

(2) 字符串比较函数strcmp
格式： strcmp(字符数组名1，字符数组名2)

功能：按照ASCII码顺序比较两个数组中的字符串，并由函数返回值返回比较结果。 
字符串1＝字符串2，返回值 0；
字符串2>字符串2，返回值 1；
字符串1<字符串2，返回值 -1。

(3) 字符串长度函数strlen
格式： strlen(字符数组名)
功能：测字符串的实际长度(不含字符串结束标志'\0') 并作为函数返回值。

(4) 字符串连接函数 strcat
格式： strcat (字符数组名1，字符数组名2)
功能：把字符数组2中的字符串连接到字符数组1 中字符串的后面，并删去字符串1后的串标志“\0”。本函数返回值是字符数组1的首地址。






========================================
|-- 二维字符串数组
----------------------------------------
1. 二维字符串数组的初始化，可以采用二维字符数组初始化形式或者字符串初始化形式，如：

char name[2][10]={{'J','o','h','n','\0'},{'M','a','r','r','y','\0'}};
char name[2][10]={{"John"},{"Marry"}};
char name[2][10]={"John","Marry"};
三种方法效果一样。

由于二维数组可以看作是一个特殊的一维数组，它的数组元素是一个一维数组。
所以二维字符串数组可以看作是这样一个一维数组，它的元素是一个字符串。






========================================
day 06 变量类别与编译预处理
----------------------------------------
局部变量与全局变量。


1. 局部变量

在函数内部定义的变量称为局部变量，它只在定义它的函数内部有效


2. 全局变量

全局变量也称为外部变量，它是在函数外部定义的变量。 它不属于哪一个函数，它属于一个源程序文件。其作用域是整个源程序

全局变量的说明符为extern。 但在一个函数之前定义的全局变量，在该函数内使用可不再加以说明。


(2) 变量的定义和说明
局部变量的定义和说明，可以不加区分。

而对于外部变量则不然，外部变量的定义和外部变量的说明并不是一回事。外部变量定义必须在所有的函数之外，且只能定义一次。

其一般形式为：
[extern] 类型说明符 变量名，变量名… 其中方括号内的extern可以省去不写。例如： int a,b;
等效于：
extern int a,b;

而外部变量说明出现在要使用该外部变量的各个函数内， 在整个程序内，可能出现多次，外部变量说明的一般形式为：
extern 类型说明符 变量名，变量名，…；


外部变量在定义时就已分配了内存单元， 外部变量定义可作初始赋值，外部变量说明不能再赋初始值， 只是表明在函数内要使用某外部变量。

从模块化角度，尽量增加内聚，减少全局变量。

同一个文件内，同名的局部变量优先于全局变量。

#include<stdio.h>
int volume(int l, int w){
	extern int h;
	printf("in func: l=%d, w=%d, h=%d\n", l, w, h);
	return(l*w*h);	
}

int main(){
	extern int w,h;
	int l=5;
	printf("in main: l=%d, w=%d, h=%d\n", l, w, h);
	printf("v=%d\n", volume(l,w) );
}
int l=3, w=4, h=5;




3. 存储类型
变量的存储方式可分为“静态存储”和“动态存储”两种。

静态存储变量是一直存在的， 而动态存储变量则时而存在时而消失。

我们又把这种由于变量存储方式不同而产生的特性称变量的生存期。 
生存期表示了变量存在的时间。 
生存期和作用域是从时间和空间这两个不同的角度来描述变量的特性，这两者既有联系，又有区别。

一个变量究竟属于哪一种存储方式， 并不能仅从其作用域来判断，还应有明确的存储类型说明。
在Ｃ语言中，对变量的存储类型说明有以下四种：
- auto 自动变量
- register 寄存器变量
- extern 外部变量
- static 静态变量

自动变量和寄存器变量属于动态存储方式， 外部变量和静态变量属于静态存储方式。
因此变量说明的完整形式应为：
	存储类型说明符 数据类型说明符 变量名
例如：
	static int a,b; 说明a,b为静态类型变量
	auto char c1,c2; 说明c1,c2为自动字符变量
	static int a[5]={1,2,3,4,5}; 说明a为静整型数组
	extern int x,y; 说明x,y为外部整型变量

(1) 自动变量

自动变量的存储空间为内存中的动态数据区，该区域中的数据随程序需要动态地生成或释放。在函数体内或者复合语句内定义的局部变量都属于自动变量。

局部变量只要不专门说明是static存储类型，都确定为自动变量，采用动态存储方式。


(2) 静态变量

静态变量的存储空间为内存中的静态数据区，该区域中的数据在整个程序的运行期间一直占用这些存储空间，直到整个程序运行结束。

所有的全局变量都是静态变量，而局部变量只有定义时加上类型修饰符static，才为局部静态变量。

静态变量的特点是在程序的整个执行过程中始终存在，但是在它作用域之外不能使用。即静态变量的生存期就是整个程序的运行期。


- 如果需要在两次
函数调用之间保持上一次函数调用结果，可以使用局部静态变量；
- 如果在每次调用函数时都必须对局部变量初始化，选择自动变量。
但是实际上局部静态变量占用内存时间较长，并且可读性差，因此，除非必要，尽量避免使用局部静态变量。

#include<stdio.h>
void increment(){
	static int a;
	printf("%d\n", a++);
}
int main(){
	increment();
	increment();
	increment();
	return 0;
}



(3) 寄存器变量

为了提高运算速度，C语言允许将一些频繁使用的局部变量定义为寄存器变量，这样程序尽可能地为它分配寄存器存放，而不用内存。

寄存器变量只要在定义时加上类型修饰符register即可。

#include<stdio.h>
void other(){
	static int nB;
	nB+=1000;
	printf("nB=%d\n", nB);
	
}

int main(){
	register int nB=-10;
	printf("-----MAIN------\n");
	printf("nB=%d\n", nB);
	
	other();
	
	printf("-----MAIN------\n");
	printf("nB=%d\n", nB);
}


(4)

如果希望一个源程序文件中的全局变量仅限于该文件使用，只要在该全局变量定义时的类型说明前加一个static。






========================================
|-- 编译预处理: 宏定义的含义和作用
----------------------------------------
当对一个源文件进行编译时， 系统将自动引用预处理程序对源程序中的预处理部分作处理， 处理完毕自动进入对源程序的编译。


1. 不带参数的宏定义的一般形式为 
	#define 标识符 字符串
它的作用是在编译预处理时，将源程序中所有标识符替换成字符串。

#include<stdio.h>
#define M (y*y+3*y)
int main(){
	int nSum, nNumber;
	printf("intput a number:");
	scanf("%d", &nNumber);
	nSum=2*M+3*M;
	printf("s=%d\n", nSum);
}

(2) 宏名的替换范围是从定义到文件结束。
提前结束可以使用 用#undef

#include<stdio.h>
# define PI 3.1415926

void f1(){
	float b=PI;
	printf("in f1: PI=%f\n", b);
}

#undef PI
void main(){
	//float a=PI; // 'PI' undeclared
	float a=3; // 'PI' undeclared
	printf("in main: PI=%f\n", a);
	f1();
}






2. 带参数的宏定义
带参数的宏定义的一般形式为
	#define 标识符(参数表) 字符串

它的作用是在编译预处理时，将源程序中所有标识符替换成字符串，并且将字符串中的参数用实际使用的参数替换。

#include<stdio.h>
#define SQ(y) ((y)*(y))
int main(){
	int sq;
	sq=SQ(3)+SQ(4);
	printf("sq=%d\n", sq);
	return 0;
}





========================================
|-- 文件包含与条件编译
----------------------------------------
1. 形式

#include <文件名>
#include "文件名"

为了节省查找时间，包含C语言的头文件时选择第一种形式，其他情况选择第二种形式。


2. 处理过程

预编译时,用被包含文件的内容取代该预处理命令，再对“包含”后的文件作一个源文件编译。


3. “文件包含”的使用时要注意：
（1）一个#include命令只能指定一个被包含的文件。 
（2）“文件包含”可以嵌套。




4. 条件编译的三种形式

预处理程序提供了条件编译的功能。 可以按不同的条件去编译不同的程序部分，因而产生不同的目标代码文件。 这对于程序的移植和调试是很有用的。

(1) 
#ifdef 标识符
	程序段1
#else
	程序段2
#endif

它的功能是，如果标识符已被 #define命令定义过则对程序段1进行编译；否则对程序段2进行编译。如果没有程序段2(它为空)，本格式中的#else可以没有，
#ifdef 标识符
	程序段1
#endif


(2) 
#ifndef 标识符
	程序段1
#else
	程序段2
#endif

将“ifdef”改为“ifndef”。
这与第一种形式的功能正相反。


(3) 
#if 常量表达式
	程序段1
#else
	程序段2
#endif 

它的功能是，如常量表达式的值为真(非0)，则对程序段1 进行编译，否则对程序段2进行编译。
因此可以使程序在不同条件下，完成不同的功能。






========================================
day07 指针基本用法 (运用指针编程是Ｃ语言最主要的风格之一)
----------------------------------------
1. 简介

int x=123;
int *point=&x;
一个指针总是一个无符号整数类型，因为计算机的内存编号总是整型的，而且不会是负数。

&a表示变量a的地址，*p表示对指针变量p指向的变量的内存单元所进行的操作。



2. 错误写法

不允许把一个数赋予指针变量，故下面的赋值是错误的：
int *p;
p=1000;

被赋值的指针变量前不能再加“*”说明符，如写为*p=&a 也是错误的。





3.指针变量作为函数参数
形参和实参指向同一个变量，当形参指向的变量发生变化时，实参指向的变量也随之变化。


Swap交换函数
父函数调用子函数,子函数如果想要修改父函数的值,必须传指针(地址),子函数内必须要解引用
子函数的改变要想影响到父函数,必须传指针,解引用
- 传指针：相当于走到房间门口，知道房间的确切位置。
- 解引用：相当于打开房门，这可以对房间内部进行改造。
https://blog.csdn.net/weixin_44134202/article/details/102870640




4. 指向一维数组的指针

C语言规定，数组名代表数组的首地址，也是第一个数组元素的地址。

C语言规定，如果p指向一个数组元素，则p+1表示指向数组该元素的下一个元素。假设p=&a[0]，则p+1表示数组元素a[1]的地址。


访问数组
a[i]
或
pa=a;
*(pa+i)




5. 数组作函数参数

(1) 为什么不能在函数里用sizeof(arr)/sizeof(*arr)来求数组大小
https://blog.csdn.net/hjf0416/article/details/50927963

int arr_size = sizeof(arr)/sizeof(arr[0]); /* incorrect use of sizeof*/

原因是数组作为参数传给函数时，是传给数组的地址，而不是传给整个的数组空间，因而
sizeof(arr)这句话会报错
正确的用法是：不在函数内部使用sizeof, 而是在传递前使用该语句获取长度，同时传递数组的指针和长度。

(2) 
数组名就是数组的首地址，实参向形参传送数组名实际上就是传送数组的地址， 形参得到该地址后也指向同一数组。 这就好象同一件物品有两个彼此不同的名称一样。




6. 指向数组元素的指针变量作函数参数

虽然数组名与指向数组首地址的指针变量都可以作函数参数，但是由于指向数组元素的指针变量不仅可以指向数组首地址，也可以指向数组中任何一个元素，所以指向数组元素的指针变量作函数参数的作用范围远远大于数组名作函数参数。



7. 指针与字符串：指向字符串的指针变量

C语言中，字符串是通过一维字符数组来存储的。因此，可以使用指向字符数组的指针变量来实现字符串的操作。

对字符串指针方式 char *ps="C Language";可以写为：
char *ps;
ps="C Language";

而对数组方式： char st[]={"C Language"};不能写为： 
char st[20];
st={"C Language"};
而只能对字符数组的各元素逐个赋值。

可看出使用指针变量更加方便。





========================================
day08 指针高级用法
----------------------------------------
1. 返回指针值的函数
所谓函数类型是指函数返回值的类型。

在Ｃ语言中允许一个函数的返回值是一个指针(即地址)， 这种返回指针值的函数称为指针型函数。

类型名 * 函数名（参数表）；




2. 指向函数的指针

在Ｃ语言中规定，一个函数总是占用一段连续的内存区， 而函数名就是该函数所占内存区的首地址。
我们可以把函数的这个首地址(或称入口地址)赋予一个指针变量， 使该指针变量指向该函数。然后通过指针变量就可以找到并调用这个函数。
我们把这种指向函数的指针变量称为“函数指针变量”。一般形式为：

类型说明符 （*指针变量名）（实参表）

其中“类型说明符”表示被指函数的返回值的类型。
“(* 指针变量名)”表示“*”后面的变量是定义的指针变量。
 最后的空括号表示指针变量所指的是一个函数。例如：
int (*pf)();
表示pf是一个指向函数入口的指针变量，该函数的返回值(函数值)是整型。

注意：
- 指向函数的指针不能做加减运算；
- (*指针变量名)"的两边的括号不可少；






(2).区分：指向函数的指针和返回指针值的函数

int(*p)()和int *p()是两个完全不同的量。

- int (*p)()是一个变量说明，说明p 是一个指向函数入口的指针变量，该函数的返回值是整型量，(*p)的两边的括号不能少。

- int *p() 则不是变量说明而是函数说明，说明p是一个指针型函数，其返回值是一个指向整型量的指针，*p两边没有括号。






3. 指针数组
本质是数组，里面的元素是指针。

类型名 *数组名[常量表达式]；
例如：char *message[10]={“one”,”two”,”three”}

上述声明的功能如下：
- 为一个包含10个元素的、名为message的数组分配空间，其中每个元素都是char指针；
- 在内存的某个地方分配空间，用于存储三个初始字符串，其中每个字符串都以空字符结尾；
- 将message[0]、message[1]、message[2]分别初始化为指向第一个字符串（one）、第二个字符串（two）、和第三个字符串（three）的第一个字符的指针。


问题：每个元素的地址是什么？多长？
竟然是连续存储的，也就是说后续赋值太长会覆盖掉下一个元素。
//todo win7测试竟然不是。







4. 指针与多维数组
不带任何下标的二维数组名表示二维数组的起始地址，对其进行加法操作时则表示作为其元素的一个一维数组（即二维数组一行）的起始地址。

只带一维下标的二维数组名表示作为其元素的一个一维数组（即二维数组一行）的起始地址，对其进行加法操作时表示该一维数组（即二维数组一行）的一个元素的地址。



(1)指向二维数组元素的指针变量

int a[3][4],*p; p=a[0];

此时p指向一维数组a[0]的起始地址，即p、a[0]、&a[0][0]相同。
对其进行加法操作时p+1等同于a[0]+1，都指向数组元素a[0][1]。所以*(p+1)等于元素a[0][1]的值。


例子: 已知二维数组multi[2][3]，输出全部元
#include<stdio.h>
int main(){
	int multi[2][3]={{1,2,3}, {10,20,30}};
	int *ptr=multi[0]; /*等价于p=&multi[0][0];*/
	int i, j;
	for(i=0; i<2; i++){
		for(j=0; j<3; j++){
			printf("multi[%d][%d]=%d, |%d (%p)\n", i,j, multi[i][j], *ptr, ptr);
			ptr++;
		}
	}
	return 0;
}

输出：
multi[0][0]=1, |1 (000000000022FE20)
multi[0][1]=2, |2 (000000000022FE24)
multi[0][2]=3, |3 (000000000022FE28)
multi[1][0]=10, |10 (000000000022FE2C)
multi[1][1]=20, |20 (000000000022FE30)
multi[1][2]=30, |30 (000000000022FE34)




(2) 指向二维数组中一维数组的指针变量

C 语言规定一种指针变量，如果该指针变量等于不带任何下标的二维数组名，指针变量指向作为二维数组元素的一个一维数组（即二维数组的一行），这样对指针变量进行加减操作则指针将在二维数组中的行上移动。

这种指针变量的定义形式如下： 类型符 (*指针变量名)[指向的一维数组元素的个数]

那么对于一个由2行3列组成的二维数组a[2][3]，如果指针变量p指向这个二维数组中包含3个元素的第一行一维数组，则指针变量p的定义和赋值形式如下：

int a[2][3], (*p)[3]; p=a; 

此时p指向二维数组a的起始地址。对其进行加法操作时p+1等同于a+1，指向包含3个元素的一维数组a[1]。所以*(p+1)等于一维数组名a[1]，*(p+1)+1等于a[1]+1，所以*(*(p+1)+1)等于a[1][1]。


指向数组的指针变量在使用时，要注意与元素是指针类型的指针数组的区别。
例如： int (*q)[3],*p[3]； 
q是指向一个包含3个整型元素的一维数组的指针变量，
p是一个由p[0]、p[1]、p[2]共3个指向整型数据的指针组成的一维数组。



#include<stdio.h>
int main(){
	int a[2][3]={ {1,2,3},{-7,-8,-9} };
	int i,j, (*ptr)[3];
	ptr=a; //注意这个定义的指针 ptr 形式，和 a 是等价的
	for(i=0; i<2; i++){
		for(j=0; j<3; j++){
			printf( "arr[%d][%d]=%d (%p)| %d | %d, (%p) \n", 
				i,j, a[i][j],&ptr[i][j],  
				ptr[i][j], *(*(ptr+i)+j), (*(ptr+i)+j) );
		}
	}
}

输出: 
arr[0][0]=1 (000000000022FE20)| 1 | 1, (000000000022FE20)
arr[0][1]=2 (000000000022FE24)| 2 | 2, (000000000022FE24)
arr[0][2]=3 (000000000022FE28)| 3 | 3, (000000000022FE28)
arr[1][0]=-7 (000000000022FE2C)| -7 | -7, (000000000022FE2C)
arr[1][1]=-8 (000000000022FE30)| -8 | -8, (000000000022FE30)
arr[1][2]=-9 (000000000022FE34)| -9 | -9, (000000000022FE34)


本例程序中，pa是一个指针数组，三个元素分别指向二维数组a的各行。
然后用循环语句输出指定的数组元素。
其中
*a[i]表示i行0列元素值；
*(*(a+i)+i)表示i行i列的元素值；
*pa[i]表示i行0列元素值；
由于p与a[0]相同，故p[i]表示0行i列的值；
*(p+i)表示0行i列的值。

读者可仔细领会元素值的各种不同的表示方法。 应该注意指针数组和二维数组指针变量的区别。 这两者虽然都可用来表示二维数组，但是其表示方法和意义是不同的。




(3) 指向指针的指针

指针的地址可以赋给另一个指针变量，这另一个指针变量就称为指向指针的指针。

指向指针的指针定义的一般形式为： 类型名 ** 指针变量名；
例如： 

#include<stdio.h>
int main(){
	int myvar=12; //变量
	int **ptr_to_ptr; 
	int *ptr=&myvar; //变量的地址保存在ptr中，ptr是地址，也被称为指针
	ptr_to_ptr=&ptr; //ptr本身的地址保存在 ptr_to_ptr 中，该变量是指向指针的指针。

	printf("value and address\n");
	printf("%d (%p)\n", myvar, &myvar);
	printf("%d (%p, %p)\n", *ptr, &ptr, ptr);
	printf("%d (%p, %p, %p)\n", **ptr_to_ptr, &ptr_to_ptr, ptr_to_ptr, *ptr_to_ptr);
	return 0;
}

输出：
value and address
12 (000000000022FE4C)
12 (000000000022FE38, 000000000022FE4C)
12 (000000000022FE40, 000000000022FE38, 000000000022FE4C)

## ptr_to_ptr -> ptr -> myvar.



例2: 用二级指针处理字符串
#include<stdio.h>
int main(){
	char **ptr; //这是指向指针的指针
	
	//这是指针数组，本质是一个一维数组，其元素是指针。
	//这些指针指向char数组。C的字符串就是char组成的一维数组。
	char *names[]={"hello", "good", "world", "bye", ""};
	
	ptr=names+1; //这个二维指针+1，表示在第二维上移动一位，指向下一个字符串。
	printf("%o: %s  ", *ptr, *ptr);// 输出是good
	ptr+=2; //再移动2个，指向bye首地址
	while(**ptr != '\0'){
		printf("%s\n", *ptr++);
	}
	
	//重置位置
	printf("\n");
	ptr=names;
	while(**ptr != '\0'){
		printf("%s\n", *ptr++);
	}
	return 0;
}

输出：
20040006: good  bye

hello
good
world
bye




5. 命令行参数

C语言允许main函数带两个参数。带参数的main函数的一般形式为：

main(int argc, char *argv[]){ } 

其中，参数argc为整型，是命令行中参数的个数，命令名作为第一个参数。
argv为指向字符串的指针数组，它的元素依次指向命令行中的各个字符串，包括命令名。

#include <stdio.h>
int main(int argc,char *argv[]){
	int i;
	printf("argc=%d\n",argc);
	for(i=0;i<argc;i++)
		printf("%d: %s\n",i, argv[i]);
	return 0;
}

测试
>09.exe this is a book
argc=5
0: 09.exe
1: this
2: is
3: a
4: book









========================================
day09/ 结构体、共用体和枚举类型
----------------------------------------









========================================
cur 
----------------------------------------

P55
P61
P64 2021/7/27
P71 2021/8/1


编译的格式：
less day05/15.c
bash makeC.sh day08 04




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------




========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



========================================
----------------------------------------



