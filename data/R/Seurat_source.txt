Seurat 包源码解析 - 首发 知乎


1. 我的合集 https://www.zhihu.com/column/c_1431016570223468544
	Seurat 4 源码解析 1 Seurat 类怎么定义的？ https://zhuanlan.zhihu.com/p/463532779
	Seurat 4 源码解析 2：Seurat 对象怎么实例化的？ https://zhuanlan.zhihu.com/p/463602480
	Seurat 4 源码解析 3：Seurat 对象的方法是怎么定义的？ https://zhuanlan.zhihu.com/p/463617297




========================================
todo list: 接下来的话题是啥？
----------------------------------------
	todo: 
		Idents<- 干了啥？
		AverageExpression 的实现？
		DoHeatmap 
		
		细胞周期的计算：
pbmc3k.final <- CellCycleScoring(
  object = pbmc3k.final,
  g2m.features = cc.genes$g2m.genes,
  s.features = cc.genes$s.genes
)
		
		如何取子集？ https://www.jianshu.com/p/50e2b6ff10d8
		如何 merge?
		如何 FindAllMarkers?
		整合？标签转换？ Integration and Label Transfer https://www.jianshu.com/p/980be19a6512
		
		
		多线程采用 future 框架？https://www.jianshu.com/p/6f556b1a0b38
			https://cran.r-project.org/web/packages/future/index.html
		
		Seurat 4.0 ||单细胞多模态数据整合算法WNN https://www.jianshu.com/p/623a8027971c


2. 发现其他 Seurat 源码解析：简书 搜 “seurat 源码”
	seurat-NormalizeData()源码解析 https://www.jianshu.com/p/2203a20cb369
	seurat-FindAllMarkers()源码解析 https://www.jianshu.com/p/f5c8f9ea84af
	https://www.jianshu.com/p/fb2e43905559
	
	(周运来)Seurat Weekly NO.14 || 读源码解决实际问题 https://www.jianshu.com/p/53036dcae5a0
		为什么Seurat的函数运行完返回的还是Seurat对象，它读入的和输出的都一样，好奇怪。
		为什么Seurat的聚类结果中编号是从零开始的，而且，细胞数量依次递减
	Seurat对象中NicheNet分析以及circos可视化 https://www.jianshu.com/p/46f487f58a9c
	Seurat Weekly NO.3|| 直接用Seurat画fig2 https://www.jianshu.com/p/4f81b65abd8b


========================================
Learn Seurat 4.0 源码学习 (2022.1.31)
----------------------------------------
Seurat单细胞分析常见代码-02 https://www.jianshu.com/p/7a02b4f063e6


1. 整体结构
源码 https://github.com/satijalab/seurat

阅读 Seurat 源码： https://www.jianshu.com/p/ab245eda9974


主要是用 R 和 C++ 写的。

下载到本地 F:\R\R_Seurat\seurat-4.1.0


(1) 主要一级文件
/seurat.Rproj 项目文件，自动定义 自己的路径。
/DESCRIPTION 项目描述，依赖包及版本
/NAMESPACE 该包暴漏出去的函数：export("Index<-")
	很多是S3类的方法：S3method(FindClusters,Seurat)
	暴漏出去的类: exportClasses(Seurat), exportClasses(AnchorSet)
	从其他包引入的方法：importFrom(cowplot,get_legend), importFrom(ggplot2,GeomViolin)
	最后2个不熟悉:
		importMethodsFrom(Matrix,t)
		useDynLib(Seurat)


(2) 主要的文件夹
R/ 主函数 .R
src/ 主函数 .cpp, .h 文件
man/ 帮助文件 .Rd

data/ 数据文件 主要是2个cell cycle 基因集合
inst/extdata/ pbmc_small 数据

tests/ 测试文件
vignettes/ 各种示例教程，官方网站源码 .Rmd





2. Seurat 类定义在哪里？
/R/objects.R 下没有，只有引用

$ find . | xargs grep "Seurat" | grep class --color=auto

./objects.R:# Get the names of objects within a Seurat object that are of a certain class
./objects.R:# @return A vector with the names of objects within the Seurat object that are of class \code{classes.keep}


搜索发现一个函数，
$ find . | xargs grep "CreateSeuratObject" --color=auto

./objects.R:    object <- CreateSeuratObject(
./objects.R:      object <- CreateSeuratObject(
./preprocessing.R:#' @inheritParams SeuratObject::CreateSeuratObject
明显还有一个包叫 SeuratObject，专门定义这类的。



(2) 在 SeuratObject 包中查找Seurat的定义
library(SeuratObject) 按F1可以看到网址 https://github.com/mojaveazure/seurat-object

SeuratObject 简介：https://mojaveazure.github.io/seurat-object/reference/Seurat-class.html

定义S4类，用于单细胞基因组数据及相关信息，比如降维嵌入，最近邻图，空间分辨率坐标。
Defines S4 classes for single-cell genomic data and associated information, such as dimensionality reduction embeddings, nearest-neighbor graphs, and spatially-resolved coordinates. 

提供数据访问方法和R原生钩子，保证其他R 用户熟悉 Seurat 类。
Provides data access methods and R-native hooks to ensure the Seurat object is familiar to other R users.

我们继续克隆代码到本地 F:\R\R_Seurat\seurat-object-4.0.4

R/ 
man/ 
src/ 
data/ 
tests/ 
NAMESPACE 看看都定义了哪些方法
	S3method("$",Seurat)
	S3method("$<-",Seurat)
	S3method("Idents<-",Seurat)
	S3method(AddMetaData,Seurat)
	S3method(dim,Seurat)
	S3method(WhichCells,Seurat)
	
	export("%||%")
	export(AddMetaData)
	export(CreateSeuratObject)
	export(FetchData)
	
	exportClasses(Seurat) #确实是这里定义的
	exportMethods(colSums) 
	
	importFrom(rlang,"%||%") #rlang 包提供了什么？
	importFrom(utils,tail)
	
	最后一个不懂
	useDynLib(SeuratObject)



(3) 看定义的文件 R/seurat.R

第 50 行有一个定义
#' @exportClass Seurat #是对外暴漏的类

Seurat <- setClass(
  Class = 'Seurat',
  slots = c(
    assays = 'list',
    meta.data = 'data.frame',
    active.assay = 'character',
    active.ident = 'factor',
    graphs = 'list',
    neighbors = 'list',
    reductions = 'list',
    images = 'list',
    project.name = 'character',
    misc = 'list',
    version = 'package_version',
    commands = 'list',
    tools = 'list'
  )
)


第 119 行还有一个小写版本（没对外暴漏。可能是老版本，少用点换行符）
seurat <- setClass(
  Class = "seurat",
  slots = c(
    raw.data = "ANY",    data = "ANY",    scale.data = "ANY",    var.genes = "vector",
    is.expr = "numeric",    ident = "factor",    meta.data = "data.frame",    project.name = "character",
    dr = "list",    assay = "list",    hvg.info = "data.frame",    imputed = "data.frame",
    cell.names = "vector",    cluster.tree = "list",    snn = "dgCMatrix",    calc.params = "list",
    kmeans = "ANY",    spatial = "ANY",    misc = "ANY",    version = "ANY"
  )
)




(4) 如何实例化 Seurat 对象？
构建对象的函数 R/Seurat.R 中的 CreateSeuratObject.default

#' @param row.names When \code{counts} is a \code{data.frame} or
#' \code{data.frame}-derived object: an optional vector of feature names to be used
#'
#' @rdname CreateSeuratObject
#' @method CreateSeuratObject default
#' @export
#'
CreateSeuratObject.default <- function(
  counts,
  project = 'SeuratProject',
  assay = 'RNA',
  names.field = 1,
  names.delim = '_',
  meta.data = NULL,
  min.cells = 0,
  min.features = 0,
  row.names = NULL,
  ...
) {
  #如果提供 meta.data
  if (!is.null(x = meta.data)) {
    # 如果 meta.data 的行名(cid)不全在 counts 的列名(cid)中，则警告
    if (!all(rownames(x = meta.data) %in% colnames(x = counts))) {
      warning("Some cells in meta.data not present in provided counts matrix")
    }
  }
  
  # 创建 assay 对象，并按照 min.cells, min.features 过滤
  assay.data <- CreateAssayObject(
    counts = counts,
    min.cells = min.cells,
    min.features = min.features,
    row.names = row.names
  )
  
  #如果提供 meta.data, 取 meta.data 行名(cid) 和 assay 列名(cid)的交集
  if (!is.null(x = meta.data)) {
    common.cells <- intersect(
      x = rownames(x = meta.data), y = colnames(x = assay.data)
    )
	# 只保留共有cid的 meta.data。
    meta.data <- meta.data[common.cells, , drop = FALSE] #这个 drop=F 啥意思？
  }
  
  # 没看懂这一句
  Key(object = assay.data) <- suppressWarnings(expr = UpdateKey(key = tolower(
    x = assay
  )))
  
  # 返回一个 CreateSeuratObject.Assay()
  return(CreateSeuratObject(
    counts = assay.data,
    project = project,
    assay = assay,
    names.field = names.field,
    names.delim = names.delim,
    meta.data = meta.data,
    ...
  ))
}



$ find . | xargs grep  -i "UseMethod" --color=auto
grep: .: Is a directory
./generics.R:  UseMethod(generic = 'AnnotateAnchors', object = anchors)
./generics.R:  UseMethod(generic = 'as.CellDataSet', object = x)

./generics.R:  UseMethod(generic = 'FindMarkers', object = object)

./generics.R:  UseMethod(generic = 'GetAssay', object = object)

./generics.R:  UseMethod(generic = 'RunPCA', object = object)

./generics.R:  UseMethod(generic = 'RunTSNE', object = object)
./generics.R:  UseMethod(generic = 'RunUMAP', object = object)
...





(5) 如何实例化　Seurat 对象？ new()

构建对象的函数 R/Seurat.R 中的 CreateSeuratObject.Assay

#' @rdname CreateSeuratObject
#' @method CreateSeuratObject Assay
#' @export
#'
CreateSeuratObject.Assay <- function(
  counts,
  project = 'SeuratProject',
  assay = 'RNA',
  names.field = 1,
  names.delim = '_',
  meta.data = NULL,
  ...
) {
  if (!is.null(x = meta.data)) {
    if (is.null(x = rownames(x = meta.data))) {
      stop("Row names not set in metadata. Please ensure that rownames of metadata match column names of data matrix")
    }
    if (length(x = setdiff(x = rownames(x = meta.data), y = colnames(x = counts)))) {
      warning("Some cells in meta.data not present in provided counts matrix.")
      meta.data <- meta.data[intersect(x = rownames(x = meta.data), y = colnames(x = counts)), , drop = FALSE]
    }
    if (is.data.frame(x = meta.data)) {
      new.meta.data <- data.frame(row.names = colnames(x = counts))
      for (ii in 1:ncol(x = meta.data)) {
        new.meta.data[rownames(x = meta.data), colnames(x = meta.data)[ii]] <- meta.data[, ii, drop = FALSE]
      }
      meta.data <- new.meta.data
    }
  }
  # Check assay key
  if (!length(x = Key(object = counts)) || !nchar(x = Key(object = counts))) {
    Key(object = counts) <- UpdateKey(key = tolower(x = assay))
  }
  assay.list <- list(counts)
  names(x = assay.list) <- assay
  # Set idents
  idents <- factor(x = unlist(x = lapply(
    X = colnames(x = counts),
    FUN = ExtractField,
    field = names.field,
    delim = names.delim
  )))
  if (any(is.na(x = idents))) {
    warning(
      "Input parameters result in NA values for initial cell identities. Setting all initial idents to the project name",
      call. = FALSE,
      immediate. = TRUE
    )
  }
  # if there are more than 100 idents, set all idents to ... name
  ident.levels <- length(x = unique(x = idents))
  if (ident.levels > 100 || ident.levels == 0 || ident.levels == length(x = idents)) {
    idents <- rep.int(x = factor(x = project), times = ncol(x = counts))
  }
  names(x = idents) <- colnames(x = counts)
  object <- new(  #这里终于见到 new() 实例化方法了
    Class = 'Seurat',
    assays = assay.list,
    meta.data = data.frame(row.names = colnames(x = counts)),
    active.assay = assay,
    active.ident = idents,
    project.name = project,
    version = packageVersion(pkg = 'SeuratObject')
  )
  object[['orig.ident']] <- idents
  # Calculate nCount and nFeature
  n.calc <- CalcN(object = counts)
  if (!is.null(x = n.calc)) {
    names(x = n.calc) <- paste(names(x = n.calc), assay, sep = '_')
    object[[names(x = n.calc)]] <- n.calc
  }
  # Add metadata
  if (!is.null(x = meta.data)) {
    object <- AddMetaData(object = object, metadata = meta.data)
  }
  return(object)
}







========================================
|-- Seurat 方法的定义
----------------------------------------

6). S4类方法的定义 setGeneric(), setMethod()

setClass("Student", slots=c(name="character", age="numeric"))
s1=new("Student", name="Tom", age=20)

正常定义方法需要先定义泛型函数，再实现该函数。
分别对应着如下2个函数。
setGeneric("getAge", function(x) standardGeneric("getAge"))
setMethod("getAge", "Student", function(x) x@age )
getAge(s1) #20

如果是已有函数，则引入该R包后只需要写出函数实现。
Seurat Object 就只使用已有泛型方法，以为迎合R用户的使用习惯，所以该包只有实现 setMethod，没有 看到泛型定义 setGeneric。


例子1: 简单获取每个行的总和，默认是用 slot='data' (log-normalize 之后的数据)。
#' @describeIn Seurat-methods Calculate \code{\link[base]{rowSums}} on a
#' \code{Seurat} object
#'
#' @importFrom Matrix rowSums
#'
#' @export
#'
#' @examples
#' head(rowSums(pbmc_small))
#'
setMethod(
  f = 'rowSums',
  signature = c('x' = 'Seurat'),
  definition = function(x, na.rm = FALSE, dims = 1, ..., slot = 'data') {
    return(Matrix::rowSums(
      x = GetAssayData(object = x, slot = slot),
      na.rm = na.rm,
      dims = dims,
      ...
    ))
  }
)




例子2：这个是直接输入 Seurat 对象并回车时显示的内容

#' @describeIn Seurat-methods Overview of a \code{Seurat} object
#'
#' @return \code{show}: Prints summary to \code{\link[base]{stdout}} and
#' invisibly returns \code{NULL}
#'
#' @importFrom methods show
#'
#' @export
#'
setMethod(
  f = "show",
  signature = "Seurat",
  definition = function(object) {
    object <- UpdateSlots(object = object)
    assays <- FilterObjects(object = object, classes.keep = 'Assay')
    nfeatures <- sum(vapply(
      X = assays,
      FUN = function(x) {
        return(nrow(x = object[[x]]))
      },
      FUN.VALUE = integer(length = 1L)
    ))
    num.assays <- length(x = assays)
    cat("An object of class", class(x = object), "\n")
    cat(
      nfeatures,
      'features across',
      ncol(x = object),
      'samples within',
      num.assays,
      ifelse(test = num.assays == 1, yes = 'assay', no = 'assays'),
      "\n"
    )
    cat(
      "Active assay:",
      DefaultAssay(object = object),
      paste0('(', nrow(x = object), ' features, ', length(x = VariableFeatures(object = object)), ' variable features)')
    )
    other.assays <- assays[assays != DefaultAssay(object = object)]
    if (length(x = other.assays) > 0) {
      cat(
        '\n',
        length(x = other.assays),
        'other',
        ifelse(test = length(x = other.assays) == 1, yes = 'assay', no = 'assays'),
        'present:',
        strwrap(x = paste(other.assays, collapse = ', '))
      )
    }
    reductions <- FilterObjects(object = object, classes.keep = 'DimReduc')
    if (length(x = reductions) > 0) {
      cat(
        '\n',
        length(x = reductions),
        'dimensional',
        ifelse(test = length(x = reductions) == 1, yes = 'reduction', no = 'reductions'),
        'calculated:',
        strwrap(x = paste(reductions, collapse = ', '))
      )
    }
    cat('\n')
  }
)













========================================
|-- 自定义函数 
----------------------------------------
1. FetchData() 
未定义其泛型函数: 
> getGeneric("FetchData")
NULL

 函数定义在 R/seurat.R:292行：
$ find R/. | xargs grep -n "FetchData" --color=auto
...
R/./seurat.R:292:FetchData <- function(object, vars, cells = NULL, slot = 'data') {

太长了，先跳过吧。





2. FilterObjects

#' Find Sub-objects of a Certain Class
#'
#' Get the names of objects within a \code{Seurat} object that are of a
#' certain class 获取Seurat对象中某个子类的对象名字
#'
#' @param object A \code{\link{Seurat}} object
#' @param classes.keep A vector of names of classes to get
#'
#' @return A vector with the names of objects within the \code{Seurat} object
#' that are of class \code{classes.keep} 
#' 返回值是 Seurat 对象中 classes.keep 指定的子类中的对象名字
#'
#' @export
#'
#' @examples
#' FilterObjects(pbmc_small)
#'
FilterObjects <- function(object, classes.keep = c('Assay', 'DimReduc')) {
  object <- UpdateSlots(object = object)
  # 获取slot对应值为list的slots名字
  slots <- na.omit(object = Filter(
    f = function(x) {
      sobj <- slot(object = object, name = x)
	  # 是list，且 不是df，且不是包版本号
      return(is.list(x = sobj) && !is.data.frame(x = sobj) && !is.package_version(x = sobj))
    },
    x = slotNames(x = object)
  ))
  # 不要 tools 和 misc 两个 slot
  slots <- grep(pattern = 'tools', x = slots, value = TRUE, invert = TRUE)
  slots <- grep(pattern = 'misc', x = slots, value = TRUE, invert = TRUE)

  # 对这些slot名字，获取其对应的值list，获取该list 的name属性返回。
  # 再解list，最后就是: "pca"  "umap"
  slots.objects <- unlist(
    x = lapply(
      X = slots,
      FUN = function(x) {
        return(names(x = slot(object = object, name = x)))
      }
    ),
    use.names = FALSE
  )
  
  # 再核验一下是不是所需要的类 
  object.classes <- sapply(
    X = slots.objects,
    FUN = function(i) {
      return(inherits(x = object[[i]], what = classes.keep))
    }
  )
  # 输出
  # pca umap 
  # TRUE TRUE
  
  # 给出TRUE值的位置编号
  object.classes <- which(x = object.classes, useNames = TRUE)
  # pca umap 
  # 1    2 
  
  # 返回这些位置编号的name
  return(names(x = object.classes))
}






========================================
|-- 内部函数，不暴漏在 NAMESPACE 文件中
----------------------------------------
1. UpdateSlots()干了什么(内部函数)？
$ find R/. | xargs grep -n "UpdateSlots" --color=auto
R/./utils.R:976:UpdateSlots <- function(object) {



#' Update slots in an object 更新对象内的slots
#'
#' @param object An object to update
#'
#' @return \code{object} with the latest slot definitions
#'
#' @importFrom methods slotNames slot
#'
#' @keywords internal #这个函数是该包的内部函数
#'
#' @noRd #不生成文档
#'
UpdateSlots <- function(object) {
  # obj 变 list
  object.list <- sapply(
    X = slotNames(x = object), #获取该对象的slot名字
    FUN = function(x) {
      return(tryCatch( #tryCatch 的使用方法？
        expr = slot(object = object, name = x), #获取该对象这个slot对应的值
        error = function(...) { #如果出错就返回NULL
          return(NULL)
        }
      ))
    },
    simplify = FALSE, #T or F 啥区别？
    USE.NAMES = TRUE #干啥用？
  )
  
  object.list <- Filter(f = Negate(f = is.null), x = object.list) #高阶函数Filter
  
  object.list <- c('Class' = class(x = object)[1], object.list) # 在list中加入新键值对
  
  object <- do.call(what = 'new', args = object.list) #新建对象
  
  # 对于新对象有而老对象没有的slot name，进入循环
  for (x in setdiff(x = slotNames(x = object), y = names(x = object.list))) {
    # 取出新对象的这个slot对应的值
    xobj <- slot(object = object, name = x)

    # 如果 该值 是vector，且不是list，且长度等于0
    if (is.vector(x = xobj) && !is.list(x = xobj) && length(x = xobj) == 0) {
      # 给该slot赋值 vector，仅1个元素
      slot(object = object, name = x) <- vector(
        mode = class(x = xobj),
        length = 1L
      )
    }
  }
  return(object)
}








========================================
|-- 源码解析 10: subset() 函数
----------------------------------------
1. 调包侠

(1) subset() 中会按照cells自动重新计算 meta.data 中的2列：Recalculate nCount and nFeature



2. 源码解析
见 gitee




3. R tips()

(1) 表达式类型的函数 #' @importFrom rlang is_quosure enquo eval_tidy //todo 没搞懂
enquo() Defuse R expressions 也叫引用，相当于 原生R的 quote() and substitute().


# 例1:
fn1=function(x, subset2=NULL){
  if( !missing(subset2)){
    subset2=enquo(subset2)
  }
  subset2;
}
a1=fn1(1, subset2=CD4>3)

> a1
<quosure>
expr: ^CD4 > 3
env:  global
> class(a1)
[1] "quosure" "formula"




例2: WhichCells.Seurat() 也有这么几个函数:
    # 获取表达式 expression。
    # 把整个try语句放到一个if中
    expr <- if (tryCatch(expr = is_quosure(x = expression), error = function(...) FALSE)) {
      expression
    } else if (is.call(x = enquo(arg = expression))) {
      enquo(arg = expression)
    } else {
      parse(text = expression)
    }



> library(rlang)
> is_quosure
function (x) 
{
    inherits(x, "quosure")
}
<bytecode: 0x000000001ce0f4d8>
<environment: namespace:rlang>


> enquo
function (arg) 
{
    .Call(rlang_enquo, substitute(arg), parent.frame())
}
<bytecode: 0x000000001f7e2618>
<environment: namespace:rlang>


> eval_tidy
function (expr, data = NULL, env = caller_env()) 
{
    .External2(rlang_ext2_eval_tidy, expr, data, env)
}
<bytecode: 0x000000001d17bec8>
<environment: namespace:rlang>






(2) 同名的函数和参数名字，在函数内部默认使用参数。想使用函数，建议加R包前缀

# df 是定义在 stats 包中的函数，给出F分布的密度。
df(1:10)
plot(df(1:10, df1=3, df2=3), type="o", ylab="Density of F Distribution")

nrow(df) #NULL
print(args(stats::df))
# function (x, df1, df2, ncp, log = FALSE) 
# NULL

# 如果定义一个函数，其参数有同名的df，
# 在函数内部会根据情况选择当参数还是函数。
# 如果指定R包前缀，则当做函数。我们尽量使用确定性强的方式！
fn1=function(df){
  print(df) #当参数处理的
  
  print(args(df))#NULL 当参数
  print(args(stats::df))#NULL #当函数
  
  df(1:10) #当函数
}
fn1(iris[1:2,])



(3) 获取与修改 error 对象中的消息内容: e$message

如果 e$message 的内容是某个值，则对应处理。

tryCatch(
  expr = iris[,6],
  error = function(e) {
    if (e$message == "undefined columns selected") {
      e$message="捕获该错误，可以自定义错误信息，或返回值\n"
      #stop(e)
      message(e)
      return(NULL)
    } else {
      stop(e)
    }
  }
)



(4) na.omit() 忽略掉NA，但是不管无穷大

> na.omit
function (object, ...) 
UseMethod("na.omit")
<bytecode: 0x0000000002c626b8>
<environment: namespace:stats>

> df1=c("a1", "b2", NA, "D4", Inf, "F6"); df1
[1] "a1"  "b2"  NA    "D4"  "Inf" "F6" 

> df2=na.omit(df1); df2
[1] "a1"  "b2"  "D4"  "Inf" "F6" 
attr(,"na.action")
[1] 3
attr(,"class")
[1] "omit"


> length(df1)
[1] 6
> length(df2)
[1] 5



(5) 取小集合在大集合的子集，并保持在大集合中的位置顺序。
cells.scaled <- cells.scaled[na.omit(object = match(x = colnames(x = x), table = cells.scaled))]


一步一步展开:
x=c(1:100)
cells.scaled=c(3, 80,1000,20,500)

rs1=match(x = x, table = cells.scaled); rs1
rs2=na.omit(rs1); rs2 #1,4, 2
cells.scaled[rs2] #3 20 80





例2: 在函数 WhichCells.Seurat 最后，也使用到了这个套路
cell.order =seq(100,1, -1) # 是最早的大集合。
cells =c(20, 4, 60, 8) # 是经过各种筛选后留下的小集合。

# 排序: 大集合在小集合中的下标，去掉na，然后是小集合的元素，按照大集合的顺序输出
cells2 <- cells[na.omit(object = match(x = cell.order, table = cells))]
cells2
# [1] 60 20  8  4







(6) `%iff%`函数，尽可能取 NULL，如果第一个不是再看第二个参数

这是 SeuratObject 包定义的函数。
> ?`%iff%`
Set a default value depending on if an object is NULL
仿照 rlang包的 x %||% y
但是作用相反: 
For %||%: y if x is NULL otherwise x
For %iff%: y if x is not NULL; otherwise x


> `%iff%`
function (x, y) 
{
    if (!is_null(x = x)) {
        return(y)
    }
    return(x)
}
<bytecode: 0x0000000010039870>
<environment: namespace:SeuratObject>




(7) dim(sce) 是怎么实现的？nrow(), ncol()
源码:
#' @describeIn Seurat-methods Number of cells and features for the active assay
#'
#' @return \code{dim}: The number of features (\code{nrow}) and cells
#' (\code{ncol}) for the default assay; \strong{note}: while the number of
#' features changes depending on the active assay, the number of cells remains
#' the same across all assays
#'
#' @export
#' @method dim Seurat
#'
#' @examples
#' # Get the number of features in an object
#' nrow(pbmc_small)
#'
#' # Get the number of cells in an object
#' ncol(pbmc_small)
#'
dim.Seurat <- function(x) {
  x <- UpdateSlots(object = x)
  return(dim(x = x[[DefaultAssay(object = x)]]))
}



示例:
# 定义一个S4类
setClass("Person", slots = c(name="character", assets="data.frame"))
# 实现这一个方法 dim，相当于实现了三个: nrow, ncol, dim
dim.Person <- function(x) {
  return(dim(x = x@assets))
}

p1=new("Person", assets=iris[1:2,], name="Jim")
p1
dim(p1) #2 5
dim(p1@assets) #2 5
nrow(p1) #2
ncol(p1) #5




(8) rownames(sce) 是怎么实现的？
源码 
#' @describeIn Seurat-methods The cell and feature names for the active assay
#'
#' @return \code{dimnames}: The feature (row) and cell (column) names;
#' \strong{note}: while the features change depending on the active assay, the
#' cell names remain the same across all assays
#'
#' @export
#' @method dimnames Seurat
#'
#' @examples
#' # Get the feature names of an object
#' rownames(pbmc_small)
#'
#' # Get the cell names of an object
#' colnames(pbmc_small)
#'
dimnames.Seurat <- function(x) {
  x <- UpdateSlots(object = x)
  return(dimnames(x = x[[DefaultAssay(object = x)]]))
}


# 实现这一个方法 dimnames，相当于实现了三个: rownames(), colnames(). dimnames()
示例：
接上例:
> rownames(p1) #定义前，返回NULL
NULL

> dimnames.Person <- function(x) {
+   return(dimnames(x = x@assets))
+ }
> rownames(p1) #定以后，返回某个slot元素的行名
[1] "1" "2"
> colnames(p1) #列名
[1] "Sepal.Length" "Sepal.Width"  "Petal.Length" "Petal.Width"  "Species"  





(9) paste()的 collapse=参数，可以把数组变为一行字符串

> paste(colnames(mtcars), collapse = ", ")
[1] "mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb"



给大佬提了修改建议，看是否采纳吧。
https://github.com/mojaveazure/seurat-object/pull/40 


idents=c(1,2,40, 41, 42)
x=1:30

# not good
stop(
  "Cannot find the following identities in the object: ",
  paste(
    idents[!idents %in% x],
    sep = ', '
  )
) 
#404142

# good
stop(
  "Cannot find the following identities in the object: ",
  paste(
    idents[!idents %in% x],
    collapse = ', '
  ) 
)
#40, 41, 42





(10) stop() 中可以有多个句子，之间没有间隔号
用法参考上一条。

> stop("this is wrong", "; today is Sunday", ". I love it!")
Error: this is wrong; today is Sunday. I love it!

恰如其分的警告和错误提醒，是一个包成熟的标志。
能让用户自动纠正自己的行为，在使用中学习。






(11) unlist(x = lapply()) 代替for循环

例1: 一个数组包含几个句子，一个句子有若干单词，把一个数组分割成单词。
expr.char=c("this is a book", "the code works")

# 使用 lapply 并指定使用函数的参数
unlist(x = lapply(X = expr.char, FUN = strsplit, split = ' '))
# [1] "this"  "is"    "a"     "book"  "the"   "code"  "works"


# 使用 for 循环要好几行
rs=c()
for(i in expr.char){
  rs2=strsplit(i, split=" ")[[1]]
  rs=c(rs, rs2)  
}
rs





例2: 拿到某些 Idents的cell barcode 字符串。

library(Seurat)
head(Idents(pbmc_small))
table(Idents(pbmc_small))
#0  1  2 
#36 25 19 

idents=c(0, 2)
object=pbmc_small


# 方法1: lapply
cells.idents <- unlist(x = lapply(
  X = idents,
  FUN = function(i) {
    # 取出等于某个ident的，返回的是 T or F 的list
    cells.use <- which(x = as.vector(x = Idents(object = object)) == i)
    # 返回cell id
    cells.use <- names(x = Idents(object = object)[cells.use])
    return(cells.use)
  }
)) #解开list unlist
head(cells.idents)
length(cells.idents) #55


# 方法2: for 循环
cells.idents2_all=c()
for(i in idents){
  cells.use2 <- which(x = as.vector(x = Idents(object = object)) == i)
  cells.use2 <- names(x = Idents(object = object)[cells.use2])
  cells.idents2_all=c(cells.idents2_all, cells.use2)
}
length(cells.idents2_all) #55

identical(cells.idents2_all, cells.idents) #T







(12) suppressWarnings() 抑制提醒

expr.char <- suppressWarnings(expr = as.character(x = expr))




(13) substitute() //todo
substitute returns the parse tree for the (unevaluated) expression expr, substituting any variables bound in env.


> a1=substitute(CD4>0.5); a1
CD4 > 0.5
> as.character(a1)
[1] ">"   "CD4" "0.5"








========================================
|-- 源码解析 11: HVFInfo/Loadings/"Idents<-"
----------------------------------------
1. 调包侠

(1) Seurat 的 Command() 是干啥的？ //todo
源码: find.command <- Command(object = object)[Command(object = object) %in% cmds]

> Command(pbmc_small)
 [1] "NormalizeData.RNA"        "ScaleData.RNA"           
 [3] "RunPCA.RNA"               "BuildSNN.RNA.pca"        
 [5] "FindClusters"             "RunTSNE.pca"             
 [7] "JackStraw.RNA.pca"        "ScoreJackStraw.pca"      
 [9] "ProjectDim.RNA.pca"       "FindVariableFeatures.RNA"


> Command(
  object = pbmc_small,
  command = "FindVariableFeatures.RNA",
  value = 'selection.method'
)
#"vst"



粗略看了一下，感觉像是重要的步骤的记录，类似日志系统，在 pbmc_small@commands 中保存。
我决定先跳过去，看样子以后还能多次遇到，或许在最后总结效果更好。



(2) "[[.Assay" 怎么定义的？

hvf.info$variable <- object[[paste0(selection.method, '.variable')]]


> head(pbmc_small@assays$RNA[[c("vst.mean", "vst.variance")]])
         vst.mean vst.variance
MS4A1      0.3875    1.0251582
CD79B      0.6000    1.2810127
CD79A      0.7000    4.3645570

> head(HVFInfo(pbmc_small@assays$RNA, selection.method = "vst"))
            mean    variance variance.standardized
MS4A1     0.3875   1.0251582             0.8983463
CD79B     0.6000   1.2810127             0.4731134
CD79A     0.7000   4.3645570             1.0862810


添加 status=T 参数
> head(HVFInfo(pbmc_small@assays$RNA, selection.method = "vst", status=T))
            mean    variance variance.standardized vst.variable
MS4A1     0.3875   1.0251582             0.8983463        FALSE
CD79B     0.6000   1.2810127             0.4731134        FALSE






2. 源码解析 










3. R tips

(1) expand.grid() 通过多个因子的组合创建数据框
Create a Data Frame from All Combinations of Factor Variables

例1: 创建3个地点 + 2个时间的组合
expand.grid(
  place=c("a", "c", "Z"),
  time=c(1,20)
)
输出:
  place time
1     a    1
2     c    1
3     Z    1
4     a   20
5     c   20
6     Z   20


例2: 源码
expand.grid(
  c('FindVariableFeatures', 'SCTransform'),
  FilterObjects(object = pbmc_small, classes.keep = 'Assay')
)
输出:
#                  Var1 Var2
#1 FindVariableFeatures  RNA
#2          SCTransform  RNA






(2) apply() 中的函数怎么指定参数？直接在后面指定
cmds <- apply(
  X = expand.grid(
    c('FindVariableFeatures', 'SCTransform'),
    FilterObjects(object = pbmc_small, classes.keep = 'Assay')
  ),
  MARGIN = 1,
  FUN = paste,
  collapse = '.'
)

> cmds
[1] "FindVariableFeatures.RNA" "SCTransform.RNA"   




(3) 大集合在小集合中的元素，其实就是交集，并保持在大集合的顺序
small_set=c(1,20,100)
big_set=1:50
big_set[big_set %in% small_set]
输出: [1]  1 20





(4) file_path_sans_ext() 是啥？去掉后缀名
sans [sænz] prep. 无，没有（等于 without）


看该函数的注释，可知它来自 tools 包: 
#' @importFrom tools file_path_sans_ext

查F1: Utilities for listing files, and manipulating file paths.

> tools::file_path_sans_ext
function (x, compression = FALSE) 
{
    if (compression) 
        x <- sub("[.](gz|bz2|xz)$", "", x)
    sub("([^.]+)\\.[[:alnum:]]+$", "\\1", x)
}
<bytecode: 0x000000001989d9b0>
<environment: namespace:tools>

传入一个参数，默认只执行最后一行。
这个正则替换，意思是：至少一个字符开头，一个点号，然后至少一个字母或数字结尾。
只保留点号前面的部分。
默认贪婪匹配，多个点号按最后一个。
总结：去掉最后一个点号及之后的部分。

> tools::file_path_sans_ext("data/xx/aa.1")
[1] "data/xx/aa"
> tools::file_path_sans_ext("data/xx/aa.12")
[1] "data/xx/aa"
> tools::file_path_sans_ext("data/xx/aa.980.txt")
[1] "data/xx/aa.980"




(5) droplevels() 去掉factor数据类型中用不到的水平 

> droplevels
function (x, ...) 
UseMethod("droplevels")
<bytecode: 0x000000000b5996c8>
<environment: namespace:base>


> a1=c(1,2,3,2,1)
> a1.f=factor(a1); a1.f
[1] 1 2 3 2 1
Levels: 1 2 3

# 取子集后，水平3就多余了
> a2=a1.f[c(1,2,4,5)]; a2
[1] 1 2 2 1
Levels: 1 2 3

# 该函数去掉多余的水平
> a3=droplevels(a2); a3
[1] 1 2 2 1
Levels: 1 2













========================================
|-- 源码解析 12: FeatureScatter()
----------------------------------------

1. 
QC 指控


(1) 如果看着可疑，可以试试参数 jitter=F
不jitter才是本来的面目，有可能很多点重合在原点(x和y都是0)。
FeatureScatter(pbmc, feature1 = "S100A9", feature2 = "DUSP1", jitter=F)


group.by=可以输入一个值，也可以输入一个数组
FeatureScatter(pbmc, feature1 = "TMSB4X", feature2 = "B2M",
               group.by = c("seurat_clusters", 'ident', "orig.ident"),
               jitter=F)





(2) 列名替换'-'为'.'，以及 ':' 为 '.'
也即是基因名不要有-或者:，否则会被替换为点号。
names.plot <- colnames(x = data) <- gsub(
	pattern = '-',
	replacement = '.',
	x = colnames(x = data),
	fixed = TRUE
)




(3) 该图顶部的相关系数怎么计算的？

# (A7) 如果需要相关系数，就计算；否则空字符串
# 直接使用的 cor(x,y)，默认的 pearson 相关系数
plot.cor <- if (isTRUE(x = plot.cor)) {
	round(x = cor(x = data[, 1], y = data[, 2]), digits = 2)
}
else(
	""
)

就是默认的 cor(x,y).


(4) 添加LOESS 局部拟合曲线
FeatureScatter(pbmc, feature1 = "TMSB4X", feature2 = "B2M", 
               cols=c(1:9), #每个类的颜色
               span=0.1, #越大越平滑，也越失去细节
               jitter=F)








2. 源码解析
见 gitee 


==>
seurat-4.1.0/R/visualization.R:5320:Bandwidth <- function(data) {












3. R tips

(1) shuffle 打乱样品顺序
> sample(1:10)
 [1]  2  8  9 10  4  5  1  3  6  7
> sample(1:10)
 [1]  9  7  1  3  4  8  5 10  6  2

如果想固定顺序，则需要设定随机数种子
> set.seed(1)
> sample(1:10)
 [1]  9  4  7  1  2  5  3 10  6  8




(2) globalVariables() 函数干啥呢？//todo
源码：
globalVariables(names = '..density..', package = 'Seurat')




(3) aes() 与 aes_string() 的用法区别？
后者可以使用变量。例子如下:

library(ggplot2)
head(mtcars)
ggplot(mtcars, aes(mpg, cyl))+geom_point()

params=c("mpg", "cyl")
ggplot(mtcars, aes_string(x=params[1], y=params[2]))+geom_point()



(4) 栅格化以降低pdf文件大小： scattermore::geom_scattermore 
ggplot2::ggplot() integration. This cooperates with the rest of ggplot (so you can use it to e.g. add rasterized scatterplots to vector output in order to reduce PDF size). 

> scattermore::geom_scattermore
function (mapping = NULL, data = NULL, stat = "identity", 
    position = "identity", ..., na.rm = FALSE, show.legend = NA, 
    inherit.aes = TRUE, interpolate = FALSE, pointsize = 0, pixels = c(512, 
        512)) 
{
    ggplot2::layer(data = data, mapping = mapping, stat = stat, 
        position = position, geom = GeomScattermore, show.legend = show.legend, 
        inherit.aes = inherit.aes, params = list(na.rm = na.rm, 
            interpolate = interpolate, pointsize = pointsize, 
            pixels = pixels, ...))
}
<bytecode: 0x000000003346b238>
<environment: namespace:scattermore>

源码:
    if (raster) {
      plot <- plot + geom_scattermore(
        mapping = aes_string(color = 'colors'),
        position = position,
        pointsize = pt.size, #这一行参数名不同
        pixels = raster.dpi #多了这一行
      )
    # 如果不栅格化
    } else {
      plot <- plot + geom_point(
        mapping = aes_string(color = 'colors'),
        position = position,
        size = pt.size
      )
    }


例：使用钻石数据集画散点图pdf，尝试降低pdf磁盘占用。

head(diamonds)
pt.size=min(1583 / nrow(x = diamonds), 1); pt.size #0.02934

pdf(file="01.pdf", width=4, height=4, useDingbats = F)
ggplot(diamonds, aes(carat, price, color=cut))+
  geom_point(size = pt.size)+
  theme_classic()
dev.off()

pdf(file="01.raster.pdf", width=4, height=4, useDingbats = F)
raster.dpi=c(512, 512)
ggplot(diamonds, aes(carat, price, color=cut))+
  scattermore::geom_scattermore(
    pixels = raster.dpi,
    pointsize = pt.size*50
  )+
  theme_classic()
dev.off()

文件大小对比: 是原来的 1/16
栅格前后: 1427k vs 88k



(5) 









========================================
|-- substitute/bquote: 表达式的语法解析树
----------------------------------------

类主要是: 
函数主要是: bquote, substitute, parse, 


deparse(substitute(x))


1. 主要资料

(1) 中文
https://blog.csdn.net/tanzuozhev/article/details/50603045
https://blog.csdn.net/sunnyxidian/article/details/9069391

(2) 英文
https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Substitutions
https://cran.r-project.org/doc/manuals/R-lang.pdf


2. 








========================================
BMMC 数据集
----------------------------------------
1. hubmap 计划
https://azimuth.hubmapconsortium.org/references/#Human%20-%20Bone%20Marrow

该计划也是用到了 snakemake 
https://github.com/satijalab/azimuth-references/blob/master/human_pbmc/Snakefile

